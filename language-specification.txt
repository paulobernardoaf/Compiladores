NOME: 

Estrutura geral de um programa:

    Se admite escopo global 
        => Sim

    Como é identificado o ponto de início de execução 
        => 
            int Main() {
                
                return 0;
            }

    Onde e como são feitas definições de variáveis globais/locais
        =>  Variáveis globais devem possuir seu tipo precedido da
            palavra "global".

            Exemplo:

                global int var;


Palavras reservadas:

    and, bool, char, do, during, else, false, float, from,
    get, global, if, int, not, or, print, return, string, true


identificador:        

    Tem o tamanho máximo de 48 caracteres e as seguintes regras:

        =>  Todas as variáveis devem iniciar com letra 
            minúscula e funções/procedimentos devem ser 
            iniciadas com letra maiúscula.

        =>  Os caracteres, a partir do segundo, podem ser letras, números ou underline.

        => Não é permitido o uso de espaços.

        => Não é permitido o uso de palavras reservadas como identificador.
    
    
Comentário:
    
    Apenas comentários por linha, identificados por '#'


Tipos e estruturas de dados:

    Coerção:
        =>  A linguagem é estáticamente tipada, ou seja, não
            admite coerção.

    Forma de declaração:
        =>  A declaração de uma variável dever ser da forma: 
        
            <Type> identifier;

            Onde o identificador caso seja uma variável, deve
            possuir obrigatoriamente o primeiro caractere uma
            letra minúscula, e caso uma função o primeiro 
            caractere deve ser uma letra maiúscula. Outros
            caracteres podem ser números, letras ou underline.

    Compatibilidade nome ou estrutura:
        =>  Nome

    Tipos de dados primitivos:

        => Inteiro

            ~>  Deve ser identificado pela palavra reservada "int"
                e representa um número inteiro de 64 bits. Seus 
                literais são uma sequência de números inteiros.

                Exemplo: 

                    int integer;
        
        => Ponto Flutuante

            ~>  Deve ser identificado pela palavra reservada "float"
                e representa um número real de 64 bits. Seus
                literais são uma sequência de números reais.

                Exemplo: 

                    float floating_point;

        => Caractere

            ~>  Deve ser identificado pela palavra reservada "char"
                e representa 1 byte que guarda um valor de 0 a 127
                referente a seu símbolo na tabela ASCII.

                Exemplo: 

                    char character;

        => Arranjos Unidimensionais

            ~>  Um vetor deve ter seu tipo seguido pelo seu
                identificador e logo após o seu tamanho 
                especificado entre colchetes. Seus literais 
                dependem do tipo utilizado e devem ser inclusos
                dentro de colchetes seperados por vírgula. 

                Exemplo: 

                    <Type> Identifier[size];

                    <Type> Identifier[size] = [<values>]

                Ou também no formato:

                    <Type>[size]
                    
                    Utilizado em identicação do tipo de retorno 
                    de uma função.
        
        => Cadeia de Caracteres

            ~>  Deve ser identificado pela palavra reservada "string"
                e representa uma sequência de caracteres: 

                    string string;

        => Booleano

            ~>  Deve ser identificado pela palavra reservada "bool"
                e representa somente 2 possíveis valores: true e
                false.

                Exemplo: 

                    bool boolean;
                    
    Operações de cada tipo:

        int     => Atribuição, Aritiméticos, Relacionais
        float   => Atribuição, Aritiméticos(*), Relacionais
        char    => Atribuição, Relacionais, Concatenação
        string  => Atribuição, Relacionais(**), Concatenação
        bool    => Atribuição, Lógicas 

        * operador de resto não incluso
        ** somente os operadores '==' e '!=' são aceitos.

    Valores padrão

        int     =>  0
        float   =>  0.0
        char    =>  ''
        string  =>  null
        bool    =>  false
    
Conjunto de Operadores:

    Aritiméticos:

        Soma            => +
        Subtração       => -
        Unário Negativo => - 
        Multiplicação   => *
        Divisão         => /
        Resto           => %

    Relacionais:

        Igual           => ==
        Menor que       => <
        Maior que       => >
        Menor ou igual  => <=
        Maior ou igual  => >=
        Diferente       => !=

    Lógicos:

        Negação Unária  => not 
        Conjunção       => and
        Disjunção       => or


    Concatenação:

        É formada pelo operador "&", que ao ser aplicado 
        concatena os dois lados da operação se os dois
        lados forem caractere ou cadeia de caracteres.

        Exemplo:

        string string = string1 & string2;
        string string = character & string;

    Precedência e Associatividade:

        Precedência | Associatividade | Operadores
       -------------|-----------------|--------------------
        1           | à direita       | - (prefixo unário)
        2           | à direita       | not
        3           | à esquerda      | *, /, %
        4           | à esquerda      | +, -
        5           | à esquerda      | <, >, <=, >=
        6           | à esquerda      | ==, !=
        7           | à esquerda      | and
        8           | à esquerda      | or
        9           | à esquerda      | & 
        10          | nenhuma         | ++, -- (sufixo unário)


    Instruções:

        Atribuição:

            Definida pelo operador '=', sendo o lado esquerdo
            o identificador a receber o valor e o direito o 
            valor ou expressão a ser atribuído.

        Estrutura condicional de uma e duas vias:

            Definida da seguinte forma:

                if expressao_logica {
                    ...
                    
                    
                } else {
                    ...
                }
               
        Estrutura iteratica com controle logico:

            Definida da seguinte forma:

                during expressao_logica {
                    ...
                }

        Estrutura iterativa controlada por contador:

            Definida da seguinte forma:

                from id = expressao_aritmetica during expressao_logica do expressao_aritmetica {
                    ...
                }

        Entrada e saída:

            Entrada:

                int a = get()

            Saída:

                print()

    Funções:

        Todas as funcões devem ser declaradas ante sde poderem ser
        utilizadas. Todos os identificadores de funções devem ser 
        precedidos do seu tipo de retorno e começar com letra
        maiúscula. Seus parâmetros devem possuir os 
        respectivos tipos.
        Funções sem o 'return' retornam o valor padrão de cada tipo.

            Exemplo: 

                functionType Function(typeA paramA, typeB paramB,...) {

                    .
                    .
                    .

                    return value;

                }


    Programas exeplos:

        Hello world:
        
            int Main() {

                print("Hello World");
                
                return 0;
            }
            
        Fibonacci:

            void Fibonacci(int value) {

                int a = 1;
                int b = 1;
                int next;

                if value == 0 {
                    return;
                }

                during next <= value {
                    
                    print(a);
                    print(", ");
                    next = a + b;
                    a = b;
                    b = next;
                    
                }

                print(a);
                print("\n");

                return;
            }

            int Main() {

                int value = get();

                Fibonacci(value);

                return 0;           

            }

        ShellSort:

            int[] ShellSort(int values[], int size) {

                int i;
                int j;
                int num;
                int gap = 1;

                during gap < size {

                    gap = gap * 3 + 1
                
                }

                during gap > 0 {

                    from i = gap during i < size do i++ {
                        num = values[i];
                        j = i;

                        during (j > gap - 1) and (num <= values[j - gap]) {

                            values[j] = values[j - gap];
                            j = j - gap;

                        }

                        values[j] = num;
                    }

                    gap = gap / 3;

                }

                return values;

            }

            int Main() {

                int i;

                print("Enter the length of array:");
                int size = get(); 

                int values[size];

                print("Enter the array");

                from i = 0 during i < size do i++ {

                    values[i] = get();
                    print(values[i]);
                    print(" ");
            
                }

                values = ShellSort(values, size);

                from i = 0 during i < size do i++ {

                    print(values[i]);
                    print(" ");
            
                }


            }

    
            
Especificação da Linguagem de Programação:

    Os analisadores léxico e sintático da linguagem serão 
    implementados em Java, utilizado o analisador preditivo
    tabular.

Especificação dos Tokens:

    Lista de Tokens:

        public enum Category {

            unknown, main, int, float, string, bool, char, void, 
            vecInt, vecFloat, vecStr, vecBool, vecChar, main,
            comma, if, else, during, from, do, semiCol, 
            begBrac, endBrac, begSqrBrac, endSqrBrac, 
            begCurBrac, endCurBrac, print, get, return, opConc,
            opAnd, opOr, opNot, opAtr, opEq, opDif, 
            opAdd, opSub, opDiv, opMult, opMod, opLowThen, 
            opHiThen, opLowThenE, opHiThenE, opGreThen, 
            opGreThenE, funcId, nameId, cteInt, cteFloat, 
            cteString, cteBool, cteChar, EOF.

        } 

    Expressões Regulares Auxiliares:

        letter = '[a-zA-Z]'
        letterLow = '[a-z]'
        letterHig = '[A-Z]'
        digit = '[0-9]'
        symbol = '[ ./:;?!+-*\/_%@&#$<>=()[]{}|"']'

    
    Lexemas:

        Main:
            main = 'Main'

        Identificador:
            nameId = '(letterLow)(letter|digit|_)*'
            funcId = '(letterHig)(letter|digit|_)*'

        Tipos Primitivos:
            int = 'int'
            float = 'float'
            char = 'char'
            string = 'String'
            bool = 'bool'

        Delimitadores:

            Escopo:
                begCurBrac = '\{'
                endCurBrac = '\}'
                
            Parâmetros:
                begBrac = '\('
                endBrac = '\)'

            Array:
                begSqrBrac = '\['
                endSqrBrac = '\]'

            Finalizador:
                semiCol = ';'

            Separador:
                comma = ','

        Definiçoes de tipos:

            cteInt      = '-?digit+'
            cteFloat    = '-?digit+(\.digit+)?'
            cteBool     = '(true|false)'
            cteChar     = ''(letter|digit|symbol_\')''
            cteString   = '"(letter|digit|symbol_\")"'
        
        Palavras reservadas de fluxo:

            if = 'if'
            else = 'else'
            from = 'from'
            during = 'during'
            do = 'do'
            return = 'return'

        Operadores lógicos:

            opAnd = 'and'
            opOr = 'or'
            opNot = 'not'

        Operadores Aritiméticos:

            opAdd = '(+)'
            opSub = '(-)'
            opMult = '(*)'
            opDiv = '(/)'
            opMod = '(%)'

        Operadores relacionais:

            opEq = '(==)'
            opDif = '(!=)'
            opGreThen = '(>)'
            opGreThenE = '(>=)'
            opLowThen = '(<)'
            opLowThenE = '(<=)'

        Operador de Concatenação:

            opConc = '&'

        Fim de arquivo:

            EOF = 'eof'